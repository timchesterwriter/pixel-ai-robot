<!DOCTYPE html>
<html lang="ru" id="htmlLang">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PIXEL AI | Voice Assistant</title>
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0a0e14">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --neon-primary: #00ff9d;
            --neon-secondary: #0094ff;
            --neon-accent: #ff00e5;
            --neon-warning: #ff4757;
            --bg-primary: #0a0e14;
            --bg-secondary: #1a1f2e;
            --bg-tertiary: #252a3a;
            --text-primary: #ffffff;
            --text-secondary: #b0b7c3;
            --card-bg: rgba(26, 31, 46, 0.8);
            --border-color: rgba(0, 255, 157, 0.2);
            --shadow-glow: 0 0 20px rgba(0, 255, 157, 0.3);
            --shadow-soft: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
            line-height: 1.6;
        }

        /* Modern Glass Header */
        .app-header {
            padding: 16px 20px;
            background: rgba(10, 14, 20, 0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--neon-primary), var(--neon-secondary));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .logo-icon i {
            color: var(--bg-primary);
            font-size: 16px;
        }

        .logo-text {
            font-weight: 700;
            font-size: 18px;
            background: linear-gradient(90deg, var(--neon-primary), var(--neon-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-status {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(0, 255, 157, 0.1);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--neon-warning);
        }

        .status-dot.active {
            background: var(--neon-primary);
            box-shadow: 0 0 10px var(--neon-primary);
            animation: pulse 2s infinite;
        }

        /* Main Container */
        .main-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 72px);
        }

        /* Chat Interface */
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow: hidden;
        }

        .messages-wrapper {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 20px;
            scroll-behavior: smooth;
        }

        .message {
            margin-bottom: 16px;
            padding: 16px;
            border-radius: 16px;
            max-width: 85%;
            word-wrap: break-word;
            position: relative;
            animation: slideIn 0.3s ease;
        }

        .message.system {
            background: rgba(0, 255, 157, 0.1);
            border-left: 4px solid var(--neon-primary);
            margin-right: auto;
        }

        .message.ai {
            background: rgba(0, 148, 255, 0.1);
            border-left: 4px solid var(--neon-secondary);
            margin-right: auto;
        }

        .message.user {
            background: rgba(255, 0, 229, 0.1);
            border-left: 4px solid var(--neon-accent);
            margin-left: auto;
            margin-right: 0;
        }

        .message.error {
            background: rgba(255, 71, 87, 0.1);
            border-left: 4px solid var(--neon-warning);
            margin-right: auto;
        }

        .message.warning {
            background: rgba(255, 170, 0, 0.1);
            border-left: 4px solid #ffaa00;
            margin-right: auto;
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: 600;
        }

        .message-time {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 8px;
            opacity: 0.7;
        }

        /* Voice Control Panel */
        .voice-panel {
            background: rgba(10, 14, 20, 0.8);
            backdrop-filter: blur(20px);
            border-top: 1px solid var(--border-color);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .voice-status-card {
            background: linear-gradient(135deg, rgba(0, 255, 157, 0.1), rgba(0, 148, 255, 0.1));
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 24px;
            text-align: center;
        }

        .voice-status-text {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 20px;
            min-height: 24px;
        }

        .voice-visualizer {
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            margin: 20px 0;
        }

        .voice-bar {
            width: 4px;
            background: var(--neon-primary);
            border-radius: 2px;
            animation: voicePulse 0.8s ease infinite alternate;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-label {
            display: block;
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .input-with-icon {
            position: relative;
        }

        .input-with-icon i {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--neon-primary);
        }

        .styled-input {
            width: 100%;
            padding: 16px 16px 16px 46px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .styled-input:focus {
            outline: none;
            border-color: var(--neon-primary);
            box-shadow: var(--shadow-glow);
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 16px;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--neon-primary), var(--neon-secondary));
            color: var(--bg-primary);
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: var(--shadow-glow);
        }

        .btn-secondary {
            background: transparent;
            color: var(--neon-primary);
            border: 1px solid var(--neon-primary);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--neon-primary);
            color: var(--bg-primary);
        }

        .btn-warning {
            background: transparent;
            color: var(--neon-warning);
            border: 1px solid var(--neon-warning);
        }

        .btn-warning:hover:not(:disabled) {
            background: var(--neon-warning);
            color: var(--bg-primary);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Quick Actions */
        .quick-actions {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 20px;
        }

        /* Status Grid */
        .status-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .status-item {
            background: var(--bg-tertiary);
            padding: 12px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .status-label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .status-value {
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Language Switcher */
        .lang-switcher {
            display: flex;
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 4px;
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        .lang-option {
            flex: 1;
            padding: 12px;
            background: transparent;
            border: none;
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .lang-option.active {
            background: var(--neon-primary);
            color: var(--bg-primary);
            box-shadow: var(--shadow-glow);
        }

        /* Model Warning */
        .model-warning {
            background: linear-gradient(135deg, rgba(255, 170, 0, 0.1), rgba(255, 100, 0, 0.1));
            border: 1px solid #ffaa00;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .model-warning i {
            color: #ffaa00;
            font-size: 20px;
            margin-top: 2px;
        }

        .model-warning-content h4 {
            color: #ffaa00;
            margin-bottom: 4px;
            font-size: 14px;
            font-weight: 600;
        }

        .model-warning-content p {
            color: var(--text-secondary);
            font-size: 13px;
            line-height: 1.5;
        }

        /* Wake Lock Indicator */
        .wake-lock-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 255, 157, 0.2);
            border: 1px solid var(--neon-primary);
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 12px;
            color: var(--neon-primary);
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .wake-lock-indicator.active {
            display: flex;
            animation: pulse 2s infinite;
        }

        /* Animations */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes voicePulse {
            0% {
                height: 5px;
                opacity: 0.3;
            }
            100% {
                height: 30px;
                opacity: 1;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--neon-primary);
            border-radius: 3px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .app-header {
                padding: 12px 16px;
            }
            
            .logo-text {
                font-size: 16px;
            }
            
            .chat-container {
                padding: 16px;
            }
            
            .message {
                max-width: 90%;
                padding: 14px;
            }
            
            .voice-panel {
                padding: 16px;
            }
            
            .btn {
                padding: 14px;
            }
            
            .quick-actions {
                grid-template-columns: 1fr;
            }
            
            .status-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (min-width: 1024px) {
            .main-container {
                flex-direction: row;
                height: calc(100vh - 72px);
            }
            
            .chat-container {
                flex: 3;
                border-right: 1px solid var(--border-color);
            }
            
            .voice-panel {
                flex: 2;
                max-width: 400px;
                border-top: none;
                overflow-y: auto;
            }
        }
    </style>
</head>
<body>
    <!-- Wake Lock Indicator -->
    <div class="wake-lock-indicator" id="wakeLockIndicator">
        <i class="fas fa-lock"></i>
        <span id="wakeLockText">WAKE LOCK ACTIVE</span>
    </div>

    <!-- Header -->
    <header class="app-header">
        <div class="header-content">
            <div class="logo">
                <div class="logo-icon">
                    <i class="fas fa-robot"></i>
                </div>
                <div class="logo-text">PIXEL AI</div>
            </div>
            <div class="header-status">
                <div class="status-indicator">
                    <span class="status-dot" id="globalStatusDot"></span>
                    <span id="globalStatusText">READY</span>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Chat Interface -->
        <div class="chat-container">
            <div class="messages-wrapper" id="messagesWrapper">
                <div class="message system">
                    <div class="message-header">
                        <i class="fas fa-terminal"></i>
                        <span>SYSTEM</span>
                    </div>
                    <div>PIXEL AI Assistant загружен. Введите API ключ OpenRouter для инициализации.</div>
                    <div class="message-time" id="currentTime"></div>
                </div>
                
                <div class="message warning">
                    <div class="message-header">
                        <i class="fas fa-exclamation-triangle"></i>
                        <span>ВНИМАНИЕ</span>
                    </div>
                    <div>Используется модель: arcee-ai/trinity-large-preview:free</div>
                    <div>Убедитесь, что ваш API ключ имеет доступ к этой модели.</div>
                </div>
                
                <div class="message system">
                    <div class="message-header">
                        <i class="fas fa-info-circle"></i>
                        <span>ИНФОРМАЦИЯ</span>
                    </div>
                    <div>Активационные фразы: "пиксель" или "pixel"</div>
                    <div>После активации скажите команду. Система будет ждать, пока вы закончите говорить.</div>
                </div>
            </div>
        </div>

        <!-- Voice Control Panel -->
        <div class="voice-panel">
            <!-- Model Warning -->
            <div class="model-warning">
                <i class="fas fa-exclamation-triangle"></i>
                <div class="model-warning-content">
                    <h4 id="modelWarningTitle">МОДЕЛЬ TRINITY</h4>
                    <p id="modelWarningText">Используется arcee-ai/trinity-large-preview:free</p>
                </div>
            </div>

            <!-- Status Grid -->
            <div class="status-grid">
                <div class="status-item">
                    <div class="status-label">AI СТАТУС</div>
                    <div class="status-value">
                        <span class="status-dot" id="aiStatusDot"></span>
                        <span id="aiStatusText">OFFLINE</span>
                    </div>
                </div>
                
                <div class="status-item">
                    <div class="status-label">ГОЛОС</div>
                    <div class="status-value">
                        <span class="status-dot" id="voiceStatusDot"></span>
                        <span id="voiceStatusText">DISABLED</span>
                    </div>
                </div>
                
                <div class="status-item">
                    <div class="status-label">ESP32</div>
                    <div class="status-value">
                        <span class="status-dot" id="espStatusDot"></span>
                        <span id="espStatusText">DISCONNECTED</span>
                    </div>
                </div>
                
                <div class="status-item">
                    <div class="status-label">ПАМЯТЬ</div>
                    <div class="status-value">
                        <span id="memoryStatusText">0%</span>
                    </div>
                </div>
            </div>

            <!-- API Configuration -->
            <div class="input-group">
                <label class="input-label" for="apiKey">OPENROUTER API KEY</label>
                <div class="input-with-icon">
                    <i class="fas fa-key"></i>
                    <input type="password" id="apiKey" class="styled-input" 
                           placeholder="sk-or-v1-xxxxxxxxxxxxxxxxxxxxxxxx">
                </div>
            </div>

            <button class="btn btn-primary" onclick="initializeSystem()" id="initBtn">
                <i class="fas fa-rocket"></i>
                <span id="initText">ИНИЦИАЛИЗИРОВАТЬ СИСТЕМУ</span>
            </button>

            <!-- ESP32 Connection -->
            <div id="espSection" style="display: none;">
                <div class="input-group">
                    <label class="input-label" for="espIp">ESP32 IP АДРЕС</label>
                    <div class="input-with-icon">
                        <i class="fas fa-microchip"></i>
                        <input type="text" id="espIp" class="styled-input" 
                               placeholder="192.168.1.100">
                    </div>
                </div>
                
                <button class="btn btn-secondary" onclick="connectToESP32()" id="espConnectBtn">
                    <i class="fas fa-plug"></i>
                    <span id="espConnectText">ПОДКЛЮЧИТЬ ESP32</span>
                </button>
            </div>

            <!-- Language Selection -->
            <div class="lang-switcher">
                <button class="lang-option active" onclick="setLanguage('ru')">
                    <i class="fas fa-language"></i>
                    <span>РУССКИЙ</span>
                </button>
                <button class="lang-option" onclick="setLanguage('en')">
                    <i class="fas fa-language"></i>
                    <span>ENGLISH</span>
                </button>
            </div>

            <!-- Activation Phrases -->
            <div style="text-align: center; margin: 20px 0;">
                <div class="input-label">АКТИВАЦИОННЫЕ ФРАЗЫ</div>
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                    <div style="padding: 8px 16px; background: rgba(255, 0, 229, 0.1); border: 1px solid var(--neon-accent); border-radius: 20px; font-size: 14px; color: var(--neon-accent);">пиксель</div>
                    <div style="padding: 8px 16px; background: rgba(255, 0, 229, 0.1); border: 1px solid var(--neon-accent); border-radius: 20px; font-size: 14px; color: var(--neon-accent);">pixel</div>
                </div>
            </div>

            <!-- Voice Control -->
            <div id="voiceControlSection" style="display: none;">
                <div class="voice-status-card">
                    <div class="voice-status-text" id="voiceStatusText">
                        Голосовое управление отключено
                    </div>
                    
                    <div class="voice-visualizer" id="voiceVisualizer"></div>
                    
                    <button class="btn btn-primary" onclick="toggleVoiceControl()" id="voiceToggleBtn">
                        <i class="fas fa-microphone"></i>
                        <span id="voiceToggleText">ВКЛЮЧИТЬ ГОЛОС</span>
                    </button>
                </div>
            </div>

            <!-- Quick Actions -->
            <div class="quick-actions" id="quickActions" style="display: none;">
                <button class="btn btn-secondary" onclick="testMicrophone()">
                    <i class="fas fa-headphones"></i>
                    <span id="testMicText">ТЕСТ МИКРОФОНА</span>
                </button>
                
                <button class="btn btn-secondary" onclick="testConnections()">
                    <i class="fas fa-wrench"></i>
                    <span id="testText">ТЕСТ СИСТЕМЫ</span>
                </button>
                
                <button class="btn btn-warning" onclick="resetSystem()">
                    <i class="fas fa-redo"></i>
                    <span id="resetText">СБРОС</span>
                </button>
                
                <button class="btn btn-secondary" onclick="clearChat()">
                    <i class="fas fa-trash"></i>
                    <span id="clearText">ОЧИСТИТЬ ЧАТ</span>
                </button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ
        // ============================================
        const SystemState = {
            // Настройки
            apiKey: '',
            espIp: '',
            language: 'ru',
            
            // Состояния
            systemActive: false,
            voiceEnabled: false,
            listeningForActivation: true,
            listeningForCommand: false,
            isProcessing: false,
            isSpeaking: false,
            espConnected: false,
            espTesting: false,
            microphoneGranted: false,
            lastActivationTime: 0,
            activationTimeout: null,
            
            // Объекты
            speechRecognition: null,
            speechSynthesis: window.speechSynthesis,
            wakeLock: null,
            visualizerInterval: null,
            
            // Тексты для интерфейса
            translations: {
                ru: {
                    // Статусы
                    globalStatusReady: "ГОТОВ",
                    globalStatusListening: "СЛУШАЮ",
                    globalStatusProcessing: "ОБРАБОТКА",
                    globalStatusSpeaking: "ГОВОРЮ",
                    
                    aiStatusOnline: "ONLINE",
                    aiStatusOffline: "OFFLINE",
                    voiceStatusActive: "ACTIVE",
                    voiceStatusDisabled: "DISABLED",
                    voiceStatusListening: "LISTENING",
                    espStatusConnected: "ПОДКЛЮЧЕН",
                    espStatusDisconnected: "ОТКЛЮЧЕН",
                    espStatusConnecting: "ПОДКЛЮЧЕНИЕ...",
                    
                    // Кнопки
                    initText: "ИНИЦИАЛИЗИРОВАТЬ СИСТЕМУ",
                    espConnectText: "ПОДКЛЮЧИТЬ ESP32",
                    espConnectingText: "ПОДКЛЮЧЕНИЕ...",
                    espDisconnectText: "ОТКЛЮЧИТЬ ESP32",
                    voiceToggleText: "ВКЛЮЧИТЬ ГОЛОС",
                    voiceToggleOffText: "ВЫКЛЮЧИТЬ ГОЛОС",
                    testMicText: "ТЕСТ МИКРОФОНА",
                    testText: "ТЕСТ СИСТЕМЫ",
                    resetText: "СБРОС",
                    clearText: "ОЧИСТИТЬ ЧАТ",
                    
                    // Голосовые статусы
                    voiceStatusMessages: {
                        disabled: "Голосовое управление отключено",
                        waiting: "Жду 'пиксель' или 'pixel'...",
                        listening: "Слушаю команду...",
                        processing: "Обрабатываю...",
                        speaking: "Отвечаю..."
                    },
                    
                    // Ответы робота
                    activationResponse: "Слушаю вас!",
                    
                    // Системные сообщения
                    systemInitialized: "Система инициализирована",
                    voiceEnabledMsg: "Голосовое управление включено",
                    voiceDisabledMsg: "Голосовое управление выключено",
                    microphoneTestSuccess: "Микрофон работает нормально",
                    microphoneTestFail: "Не удалось получить доступ к микрофону",
                    espConnectedMsg: "ESP32 подключен",
                    espDisconnectedMsg: "ESP32 отключен",
                    espErrorMsg: "Ошибка подключения к ESP32",
                    
                    // Предупреждение модели
                    modelWarningTitle: "МОДЕЛЬ TRINITY",
                    modelWarningText: "Используется arcee-ai/trinity-large-preview:free",
                    
                    // Wake Lock
                    wakeLockText: "WAKE LOCK АКТИВЕН"
                },
                en: {
                    // Statuses
                    globalStatusReady: "READY",
                    globalStatusListening: "LISTENING",
                    globalStatusProcessing: "PROCESSING",
                    globalStatusSpeaking: "SPEAKING",
                    
                    aiStatusOnline: "ONLINE",
                    aiStatusOffline: "OFFLINE",
                    voiceStatusActive: "ACTIVE",
                    voiceStatusDisabled: "DISABLED",
                    voiceStatusListening: "LISTENING",
                    espStatusConnected: "CONNECTED",
                    espStatusDisconnected: "DISCONNECTED",
                    espStatusConnecting: "CONNECTING...",
                    
                    // Buttons
                    initText: "INITIALIZE SYSTEM",
                    espConnectText: "CONNECT ESP32",
                    espConnectingText: "CONNECTING...",
                    espDisconnectText: "DISCONNECT ESP32",
                    voiceToggleText: "ENABLE VOICE",
                    voiceToggleOffText: "DISABLE VOICE",
                    testMicText: "TEST MICROPHONE",
                    testText: "TEST SYSTEM",
                    resetText: "RESET",
                    clearText: "CLEAR CHAT",
                    
                    // Voice statuses
                    voiceStatusMessages: {
                        disabled: "Voice control disabled",
                        waiting: "Waiting for 'пиксель' or 'pixel'...",
                        listening: "Listening for command...",
                        processing: "Processing...",
                        speaking: "Speaking..."
                    },
                    
                    // Robot responses
                    activationResponse: "I'm listening!",
                    
                    // System messages
                    systemInitialized: "System initialized",
                    voiceEnabledMsg: "Voice control enabled",
                    voiceDisabledMsg: "Voice control disabled",
                    microphoneTestSuccess: "Microphone working normally",
                    microphoneTestFail: "Failed to access microphone",
                    espConnectedMsg: "ESP32 connected",
                    espDisconnectedMsg: "ESP32 disconnected",
                    espErrorMsg: "Error connecting to ESP32",
                    
                    // Model warning
                    modelWarningTitle: "TRINITY MODEL",
                    modelWarningText: "Using arcee-ai/trinity-large-preview:free",
                    
                    // Wake Lock
                    wakeLockText: "WAKE LOCK ACTIVE"
                }
            }
        };

        // ============================================
        // ФУНКЦИИ ИНТЕРФЕЙСА
        // ============================================
        function addMessage(text, type = 'system', sender = 'SYSTEM') {
            const messagesWrapper = document.getElementById('messagesWrapper');
            const now = new Date();
            const timestamp = now.toLocaleTimeString('ru-RU', { 
                hour: '2-digit', 
                minute: '2-digit',
                second: '2-digit'
            });
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            let icon = 'fa-terminal';
            if (type === 'ai') icon = 'fa-robot';
            else if (type === 'user') icon = 'fa-user';
            else if (type === 'error') icon = 'fa-exclamation-circle';
            
            messageDiv.innerHTML = `
                <div class="message-header">
                    <i class="fas ${icon}"></i>
                    <span>${sender}</span>
                </div>
                <div>${text}</div>
                <div class="message-time">${timestamp}</div>
            `;
            
            messagesWrapper.appendChild(messageDiv);
            messagesWrapper.scrollTop = messagesWrapper.scrollHeight;
            
            // Управление памятью
            SystemState.logEntries++;
            updateMemoryStatus();
            
            if (SystemState.logEntries > 50) {
                const firstMessage = messagesWrapper.querySelector('.message');
                if (firstMessage) {
                    messagesWrapper.removeChild(firstMessage);
                    SystemState.logEntries--;
                }
            }
        }

        function updateMemoryStatus() {
            const percent = Math.min(100, Math.round((SystemState.logEntries / 50) * 100));
            document.getElementById('memoryStatusText').textContent = `${percent}%`;
        }

        function updateGlobalStatus(status, indicator = 'ready') {
            const globalStatusDot = document.getElementById('globalStatusDot');
            const globalStatusText = document.getElementById('globalStatusText');
            
            if (globalStatusText) globalStatusText.textContent = status;
            if (globalStatusDot) {
                globalStatusDot.className = 'status-dot';
                if (indicator === 'active') {
                    globalStatusDot.classList.add('active');
                }
            }
        }

        function updateStatusDisplay() {
            const t = SystemState.translations[SystemState.language];
            
            // AI Status
            const aiDot = document.getElementById('aiStatusDot');
            const aiText = document.getElementById('aiStatusText');
            if (aiDot && aiText) {
                aiDot.className = SystemState.systemActive ? 'status-dot active' : 'status-dot';
                aiText.textContent = SystemState.systemActive ? t.aiStatusOnline : t.aiStatusOffline;
            }
            
            // Voice Status
            const voiceDot = document.getElementById('voiceStatusDot');
            const voiceText = document.getElementById('voiceStatusText');
            if (voiceDot && voiceText) {
                if (SystemState.voiceEnabled) {
                    voiceDot.className = 'status-dot active';
                    voiceText.textContent = SystemState.listeningForActivation ? t.voiceStatusMessages.waiting : 
                                           SystemState.listeningForCommand ? t.voiceStatusMessages.listening : t.voiceStatusActive;
                } else {
                    voiceDot.className = 'status-dot';
                    voiceText.textContent = t.voiceStatusDisabled;
                }
            }
            
            // ESP32 Status
            const espDot = document.getElementById('espStatusDot');
            const espText = document.getElementById('espStatusText');
            if (espDot && espText) {
                if (SystemState.espTesting) {
                    espDot.className = 'status-dot active';
                    espText.textContent = t.espStatusConnecting;
                } else if (SystemState.espConnected) {
                    espDot.className = 'status-dot active';
                    espText.textContent = t.espStatusConnected;
                } else {
                    espDot.className = 'status-dot';
                    espText.textContent = t.espStatusDisconnected;
                }
            }
            
            // Глобальный статус
            if (SystemState.voiceEnabled) {
                if (SystemState.listeningForActivation) {
                    updateGlobalStatus(t.globalStatusListening, 'active');
                } else if (SystemState.listeningForCommand) {
                    updateGlobalStatus(t.globalStatusListening, 'active');
                } else if (SystemState.isProcessing) {
                    updateGlobalStatus(t.globalStatusProcessing, 'active');
                } else if (SystemState.isSpeaking) {
                    updateGlobalStatus(t.globalStatusSpeaking, 'active');
                } else {
                    updateGlobalStatus(t.globalStatusReady, 'active');
                }
            } else {
                updateGlobalStatus(t.globalStatusReady, SystemState.systemActive ? 'active' : 'ready');
            }
        }

        function updateVoiceStatus(messageKey) {
            const voiceStatusText = document.getElementById('voiceStatusText');
            const t = SystemState.translations[SystemState.language];
            
            if (voiceStatusText) {
                voiceStatusText.textContent = t.voiceStatusMessages[messageKey] || messageKey;
            }
        }

        function updateVisualizer() {
            const visualizer = document.getElementById('voiceVisualizer');
            const isActive = SystemState.listeningForActivation || SystemState.listeningForCommand || SystemState.isSpeaking;
            const barCount = SystemState.isSpeaking ? 40 : 20;
            
            if (!visualizer) return;
            
            if (!isActive) {
                visualizer.innerHTML = '';
                return;
            }
            
            let html = '';
            for (let i = 0; i < barCount; i++) {
                const height = SystemState.isSpeaking 
                    ? Math.floor(Math.random() * 40 + 10)
                    : Math.floor(Math.random() * 20 + 5);
                const delay = i * (SystemState.isSpeaking ? 0.03 : 0.05);
                const opacity = 0.3 + Math.random() * 0.7;
                html += `<div class="voice-bar" style="height:${height}px;opacity:${opacity};animation-delay:${delay}s"></div>`;
            }
            
            visualizer.innerHTML = html;
        }

        function setLanguage(lang) {
            SystemState.language = lang;
            document.getElementById('htmlLang').lang = lang;
            
            // Обновляем кнопки языка
            document.querySelectorAll('.lang-option').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.closest('.lang-option').classList.add('active');
            
            // Обновляем интерфейс
            updateInterfaceLanguage();
            
            // Перезапускаем распознавание если активно
            if (SystemState.voiceEnabled && SystemState.speechRecognition) {
                restartSpeechRecognition();
            }
            
            addMessage(lang === 'ru' ? 'Язык изменен на Русский' : 'Language changed to English', 'system');
        }

        function updateInterfaceLanguage() {
            const t = SystemState.translations[SystemState.language];
            
            // Обновляем кнопки
            const initBtn = document.getElementById('initBtn');
            if (initBtn) initBtn.querySelector('span').textContent = t.initText;
            
            const espConnectBtn = document.getElementById('espConnectBtn');
            if (espConnectBtn) espConnectBtn.querySelector('span').textContent = t.espConnectText;
            
            const testMicBtn = document.getElementById('testMicText');
            if (testMicBtn) testMicBtn.textContent = t.testMicText;
            
            const testTextBtn = document.getElementById('testText');
            if (testTextBtn) testTextBtn.textContent = t.testText;
            
            const resetBtn = document.getElementById('resetText');
            if (resetBtn) resetBtn.textContent = t.resetText;
            
            const clearBtn = document.getElementById('clearText');
            if (clearBtn) clearBtn.textContent = t.clearText;
            
            const voiceToggleBtn = document.getElementById('voiceToggleBtn');
            if (voiceToggleBtn) {
                if (SystemState.voiceEnabled) {
                    voiceToggleBtn.querySelector('span').textContent = t.voiceToggleOffText;
                } else {
                    voiceToggleBtn.querySelector('span').textContent = t.voiceToggleText;
                }
            }
            
            // Обновляем модель предупреждения
            const modelWarningTitle = document.getElementById('modelWarningTitle');
            if (modelWarningTitle) modelWarningTitle.textContent = t.modelWarningTitle;
            
            const modelWarningText = document.getElementById('modelWarningText');
            if (modelWarningText) modelWarningText.textContent = t.modelWarningText;
            
            // Обновляем Wake Lock
            const wakeLockText = document.getElementById('wakeLockText');
            if (wakeLockText) wakeLockText.textContent = t.wakeLockText;
            
            // Обновляем статус голоса
            if (SystemState.voiceEnabled) {
                if (SystemState.listeningForActivation) {
                    updateVoiceStatus('waiting');
                } else if (SystemState.listeningForCommand) {
                    updateVoiceStatus('listening');
                } else if (SystemState.isProcessing) {
                    updateVoiceStatus('processing');
                } else if (SystemState.isSpeaking) {
                    updateVoiceStatus('speaking');
                }
            } else {
                updateVoiceStatus('disabled');
            }
            
            // Обновляем все статусы системы
            updateStatusDisplay();
        }

        // ============================================
        // ГОЛОСОВОЕ УПРАВЛЕНИЕ (ИСПРАВЛЕННАЯ ЛОГИКА)
        // ============================================
        async function initializeSpeechRecognition() {
            // Проверяем поддержку
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                addMessage('Браузер не поддерживает распознавание речи', 'error');
                return false;
            }
            
            // Запрашиваем разрешение на микрофон
            try {
                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });
                    
                    // Освобождаем поток после проверки разрешения
                    stream.getTracks().forEach(track => track.stop());
                    
                    SystemState.microphoneGranted = true;
                    addMessage('Разрешение на микрофон получено', 'system');
                }
            } catch (error) {
                addMessage('Разрешение на микрофон не получено', 'error');
                return false;
            }
            
            // Создаем объект распознавания
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            SystemState.speechRecognition = new SpeechRecognition();
            
            // Настройки - ВАЖНО: непрерывное распознавание с таймаутом
            SystemState.speechRecognition.continuous = true;
            SystemState.speechRecognition.interimResults = false;
            SystemState.speechRecognition.lang = SystemState.language === 'ru' ? 'ru-RU' : 'en-US';
            SystemState.speechRecognition.maxAlternatives = 1;
            
            // События
            SystemState.speechRecognition.onresult = (event) => {
                const result = event.results[event.results.length - 1];
                if (!result.isFinal) return;
                
                const transcript = result[0].transcript.toLowerCase();
                const confidence = result[0].confidence;
                
                console.log(`Распознано: "${transcript}" (${(confidence * 100).toFixed(1)}%)`);
                addMessage(transcript, 'user', 'USER');
                
                if (SystemState.listeningForActivation) {
                    handleActivation(transcript);
                } else if (SystemState.listeningForCommand) {
                    handleCommand(transcript);
                }
            };
            
            SystemState.speechRecognition.onerror = (event) => {
                if (event.error === 'no-speech' || event.error === 'audio-capture') {
                    // Тихие ошибки - игнорируем
                    return;
                }
                
                console.error('Ошибка распознавания:', event.error);
                
                // Автоматический перезапуск
                if (SystemState.voiceEnabled) {
                    setTimeout(() => {
                        if (SystemState.speechRecognition) {
                            try {
                                SystemState.speechRecognition.stop();
                                setTimeout(startRecognition, 1000);
                            } catch (e) {}
                        }
                    }, 1000);
                }
            };
            
            SystemState.speechRecognition.onend = () => {
                // Автоматический перезапуск если система активна
                if (SystemState.voiceEnabled && SystemState.systemActive) {
                    setTimeout(startRecognition, 500);
                }
            };
            
            return true;
        }

        function startRecognition() {
            if (!SystemState.voiceEnabled || !SystemState.speechRecognition || SystemState.isProcessing) return;
            
            try {
                SystemState.speechRecognition.start();
            } catch (error) {
                console.log('Ошибка запуска распознавания:', error);
                if (SystemState.voiceEnabled) {
                    setTimeout(startRecognition, 1000);
                }
            }
        }

        function restartSpeechRecognition() {
            if (SystemState.speechRecognition) {
                try {
                    SystemState.speechRecognition.stop();
                } catch (e) {}
                setTimeout(() => {
                    if (SystemState.voiceEnabled) {
                        SystemState.speechRecognition.lang = SystemState.language === 'ru' ? 'ru-RU' : 'en-US';
                        startRecognition();
                    }
                }, 300);
            }
        }

        function handleActivation(transcript) {
            // Проверяем обе активационные фразы независимо от языка
            if (transcript.includes('пиксель') || transcript.includes('pixel')) {
                addMessage('✓ Активационная фраза распознана', 'system');
                
                // Сохраняем время активации
                SystemState.lastActivationTime = Date.now();
                
                // Переходим в режим ожидания команды
                SystemState.listeningForActivation = false;
                SystemState.listeningForCommand = true;
                
                updateStatusDisplay();
                updateVoiceStatus('listening');
                
                // Запускаем таймер для возврата в режим активации через 15 секунд
                if (SystemState.activationTimeout) {
                    clearTimeout(SystemState.activationTimeout);
                }
                SystemState.activationTimeout = setTimeout(() => {
                    if (SystemState.listeningForCommand && !SystemState.isProcessing) {
                        resetToActivationMode();
                        addMessage('Таймаут: возврат к ожиданию активации', 'system');
                    }
                }, 15000);
                
                // Отвечаем на активацию
                const response = SystemState.translations[SystemState.language].activationResponse;
                speakText(response);
                
                addMessage(response, 'ai', 'PIXEL');
            }
        }

        function handleCommand(transcript) {
            // Останавливаем таймер
            if (SystemState.activationTimeout) {
                clearTimeout(SystemState.activationTimeout);
                SystemState.activationTimeout = null;
            }
            
            SystemState.listeningForCommand = false;
            SystemState.isProcessing = true;
            
            updateStatusDisplay();
            updateVoiceStatus('processing');
            
            // Отправляем запрос к AI
            processAIRequest(transcript);
        }

        // ============================================
        // AI ОБРАБОТКА (ARCEE TRINITY)
        // ============================================
        async function processAIRequest(prompt) {
            try {
                addMessage('Обработка запроса...', 'system');
                
                // Системный промпт без смайликов и с четкими инструкциями
                const systemPrompt = SystemState.language === 'ru' 
                    ? `Ты робот Пиксель. Отвечай максимально кратко (1-2 фразы). 
                       Не используй смайлики или эмодзи в ответах.
                       Если нужно управлять устройствами, используй команды:
                       LED_ON - включить свет, LED_OFF - выключить свет.
                       Формат ответа строго: Text: [твой текст ответа] Commands: [команда или null]
                       Только текст после "Text:" будет озвучен и показан пользователю.`
                    : `You are Pixel robot. Respond very briefly (1-2 phrases).
                       Do not use smileys or emojis in responses.
                       If you need to control devices, use commands:
                       LED_ON - turn on lights, LED_OFF - turn off lights.
                       Response format strictly: Text: [your response text] Commands: [command or null]
                       Only text after "Text:" will be spoken and shown to the user.`;
                
                const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                    method: "POST",
                    headers: {
                        "Authorization": `Bearer ${SystemState.apiKey}`,
                        "HTTP-Referer": window.location.href,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        "model": "arcee-ai/trinity-large-preview:free",
                        "messages": [
                            {
                                "role": "system",
                                "content": systemPrompt
                            },
                            { "role": "user", "content": prompt }
                        ],
                        "temperature": 0.7,
                        "max_tokens": 150
                    })
                });

                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error.message || 'Ошибка API');
                }

                if (!data.choices || !data.choices[0]) {
                    throw new Error('Некорректный ответ от API');
                }

                const aiRaw = data.choices[0].message.content;
                
                // Извлекаем текст и команду
                const textMatch = aiRaw.match(/Text:\s*(.*?)(?:\s*Commands:|$)/i);
                const commandMatch = aiRaw.match(/Commands:\s*(\w+)/i);
                
                const txt = textMatch ? textMatch[1].trim() : aiRaw;
                const cmd = commandMatch ? commandMatch[1].toUpperCase() : "null";

                // Очищаем текст от возможных остатков формата
                const cleanText = txt.replace(/Commands:\s*\w+/i, '').trim();
                
                addMessage(cleanText, 'ai', 'PIXEL');

                // Отправляем команду на ESP32 если есть подключение
                if ((cmd === "LED_ON" || cmd === "LED_OFF") && SystemState.espConnected && SystemState.espIp) {
                    try {
                        // Используем img для отправки команды (обход CORS)
                        const img = new Image();
                        img.src = `http://${SystemState.espIp}/command?cmd=${encodeURIComponent(cmd)}&_=${Date.now()}`;
                        
                        img.onload = () => {
                            addMessage(`Команда [${cmd}] отправлена на ESP32`, 'system');
                        };
                        
                        img.onerror = () => {
                            addMessage(`Ошибка отправки команды на ESP32`, 'error');
                        };
                        
                    } catch (e) {
                        addMessage(`Ошибка отправки команды: ${e.message}`, 'error');
                    }
                }

                // Озвучиваем ответ (только текст, без команд)
                speakText(cleanText);

            } catch (error) {
                console.error('Ошибка AI:', error);
                addMessage(`Ошибка: ${error.message}`, 'error');
                
                // Возвращаемся к прослушиванию активационной фразы
                setTimeout(() => {
                    resetToActivationMode();
                }, 1000);
            }
        }

        // ============================================
        // СИНТЕЗ РЕЧИ
        // ============================================
        function speakText(text) {
            if (!SystemState.speechSynthesis) return;
            
            window.speechSynthesis.cancel();
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = SystemState.language === 'ru' ? 'ru-RU' : 'en-US';
            utterance.rate = 1.0;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;
            
            utterance.onstart = () => {
                SystemState.isSpeaking = true;
                updateStatusDisplay();
                updateVoiceStatus('speaking');
            };
            
            utterance.onend = () => {
                SystemState.isSpeaking = false;
                SystemState.isProcessing = false;
                
                // После ответа возвращаемся к ожиданию активационной фразы
                setTimeout(() => {
                    resetToActivationMode();
                }, 500);
            };
            
            utterance.onerror = () => {
                SystemState.isSpeaking = false;
                SystemState.isProcessing = false;
                
                // В случае ошибки возвращаемся к ожиданию активации
                setTimeout(() => {
                    resetToActivationMode();
                }, 500);
            };
            
            window.speechSynthesis.speak(utterance);
        }

        function resetToActivationMode() {
            SystemState.listeningForActivation = true;
            SystemState.listeningForCommand = false;
            SystemState.isProcessing = false;
            
            updateStatusDisplay();
            updateVoiceStatus('waiting');
            
            // Останавливаем таймер если он есть
            if (SystemState.activationTimeout) {
                clearTimeout(SystemState.activationTimeout);
                SystemState.activationTimeout = null;
            }
            
            addMessage('Ожидание активационной фразы...', 'system');
        }

        // ============================================
        // ПОДКЛЮЧЕНИЕ ESP32
        // ============================================
        async function connectToESP32() {
            const espIp = document.getElementById('espIp').value.trim();
            
            if (!espIp) {
                addMessage('Введите IP адрес ESP32', 'error');
                return;
            }
            
            SystemState.espIp = espIp;
            SystemState.espTesting = true;
            updateStatusDisplay();
            
            addMessage('Подключение к ESP32...', 'system');
            
            try {
                // Используем таймаут для проверки подключения
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 3000);
                
                // Пробуем отправить простой запрос для проверки подключения
                const img = new Image();
                img.src = `http://${espIp}/?t=${Date.now()}`;
                
                img.onload = () => {
                    clearTimeout(timeoutId);
                    
                    // Сохраняем IP в localStorage
                    localStorage.setItem('pixel_esp_ip', espIp);
                    
                    SystemState.espConnected = true;
                    SystemState.espTesting = false;
                    updateStatusDisplay();
                    
                    addMessage('✓ ESP32 подключен', 'system');
                };
                
                img.onerror = () => {
                    clearTimeout(timeoutId);
                    SystemState.espTesting = false;
                    SystemState.espConnected = false;
                    updateStatusDisplay();
                    
                    const t = SystemState.translations[SystemState.language];
                    addMessage(t.espErrorMsg, 'error');
                };
                
            } catch (error) {
                SystemState.espTesting = false;
                SystemState.espConnected = false;
                updateStatusDisplay();
                
                const t = SystemState.translations[SystemState.language];
                addMessage(t.espErrorMsg, 'error');
                console.error('Ошибка подключения к ESP32:', error);
            }
        }

        // ============================================
        // ОСНОВНЫЕ ФУНКЦИИ СИСТЕМЫ
        // ============================================
        async function initializeSystem() {
            const apiKey = document.getElementById('apiKey').value.trim();
            
            if (!apiKey) {
                addMessage('Введите API ключ OpenRouter!', 'error');
                return;
            }
            
            // Сохраняем настройки
            SystemState.apiKey = apiKey;
            
            // Блокируем кнопку
            const initBtn = document.getElementById('initBtn');
            if (initBtn) {
                initBtn.disabled = true;
                initBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span>ИНИЦИАЛИЗАЦИЯ...</span>';
            }
            
            updateGlobalStatus('ИНИЦИАЛИЗАЦИЯ', 'active');
            
            try {
                // Проверяем API ключ
                const testResponse = await fetch('https://openrouter.ai/api/v1/models', {
                    headers: { 
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!testResponse.ok) {
                    throw new Error('Неверный API ключ или ошибка доступа к API');
                }
                
                const models = await testResponse.json();
                const trinityModel = models.data?.find(model => 
                    model.id === 'arcee-ai/trinity-large-preview:free'
                );
                
                if (!trinityModel) {
                    addMessage('⚠ Модель Trinity может быть недоступна с вашим ключом', 'warning');
                }
                
                addMessage('✓ API ключ проверен', 'system');
                addMessage('Используется модель: arcee-ai/trinity-large-preview:free', 'system');
                
                // Инициализируем распознавание речи
                const speechInit = await initializeSpeechRecognition();
                if (!speechInit) {
                    throw new Error('Ошибка инициализации распознавания речи');
                }
                
                // Активируем систему
                SystemState.systemActive = true;
                
                // Показываем элементы управления
                document.getElementById('espSection').style.display = 'block';
                document.getElementById('voiceControlSection').style.display = 'block';
                document.getElementById('quickActions').style.display = 'grid';
                
                // Обновляем интерфейс
                updateInterfaceLanguage();
                updateStatusDisplay();
                
                addMessage('✓ Система инициализирована', 'system');
                addMessage('Активационные фразы: "пиксель" или "pixel"', 'system');
                addMessage(`Язык: ${SystemState.language.toUpperCase()}`, 'system');
                
                // Включаем Wake Lock для мобильных устройств
                if ('wakeLock' in navigator) {
                    try {
                        SystemState.wakeLock = await navigator.wakeLock.request('screen');
                        document.getElementById('wakeLockIndicator').classList.add('active');
                        addMessage('✓ Wake Lock активирован', 'system');
                    } catch (err) {
                        // Игнорируем ошибку Wake Lock
                    }
                }
                
                // Запускаем визуализатор
                if (SystemState.visualizerInterval) {
                    clearInterval(SystemState.visualizerInterval);
                }
                SystemState.visualizerInterval = setInterval(updateVisualizer, 100);
                
            } catch (error) {
                addMessage(`Ошибка инициализации: ${error.message}`, 'error');
                if (initBtn) {
                    initBtn.disabled = false;
                    initBtn.innerHTML = '<i class="fas fa-rocket"></i><span id="initText">ИНИЦИАЛИЗИРОВАТЬ СИСТЕМУ</span>';
                }
                updateGlobalStatus('ОШИБКА', 'ready');
            }
        }

        async function toggleVoiceControl() {
            if (!SystemState.systemActive) {
                addMessage('Сначала инициализируйте систему', 'error');
                return;
            }
            
            const voiceToggleBtn = document.getElementById('voiceToggleBtn');
            const t = SystemState.translations[SystemState.language];
            
            if (!SystemState.voiceEnabled) {
                // Включаем голосовое управление
                SystemState.voiceEnabled = true;
                if (voiceToggleBtn) {
                    voiceToggleBtn.innerHTML = '<i class="fas fa-microphone-slash"></i><span>' + t.voiceToggleOffText + '</span>';
                }
                addMessage(t.voiceEnabledMsg, 'system');
                
                // Начинаем слушать активационную фразу
                SystemState.listeningForActivation = true;
                SystemState.listeningForCommand = false;
                
                updateStatusDisplay();
                updateVoiceStatus('waiting');
                
                // Запускаем распознавание
                startRecognition();
                
            } else {
                // Выключаем голосовое управление
                SystemState.voiceEnabled = false;
                if (voiceToggleBtn) {
                    voiceToggleBtn.innerHTML = '<i class="fas fa-microphone"></i><span>' + t.voiceToggleText + '</span>';
                }
                addMessage(t.voiceDisabledMsg, 'system');
                
                // Останавливаем распознавание
                if (SystemState.speechRecognition) {
                    try {
                        SystemState.speechRecognition.stop();
                    } catch (e) {}
                }
                
                // Останавливаем речь
                if (SystemState.speechSynthesis) {
                    window.speechSynthesis.cancel();
                }
                
                updateStatusDisplay();
                updateVoiceStatus('disabled');
                
                // Сбрасываем состояния
                SystemState.listeningForActivation = false;
                SystemState.listeningForCommand = false;
                SystemState.isProcessing = false;
                SystemState.isSpeaking = false;
                
                // Останавливаем таймер
                if (SystemState.activationTimeout) {
                    clearTimeout(SystemState.activationTimeout);
                    SystemState.activationTimeout = null;
                }
            }
        }

        async function testMicrophone() {
            const t = SystemState.translations[SystemState.language];
            
            try {
                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    
                    addMessage(t.microphoneTestSuccess, 'system');
                    
                    // Освобождаем поток
                    stream.getTracks().forEach(track => track.stop());
                } else {
                    throw new Error('API микрофона не поддерживается');
                }
            } catch (error) {
                addMessage(t.microphoneTestFail, 'error');
            }
        }

        async function testConnections() {
            if (!SystemState.systemActive) {
                addMessage('Система не инициализирована', 'error');
                return;
            }
            
            const t = SystemState.translations[SystemState.language];
            addMessage('Тестирование соединений...', 'system');
            
            // Тест AI
            try {
                await fetch('https://openrouter.ai/api/v1/auth/key', {
                    headers: { 'Authorization': `Bearer ${SystemState.apiKey}` }
                });
                addMessage('✓ AI соединение: OK', 'system');
            } catch {
                addMessage('✗ AI соединение: ОШИБКА', 'error');
            }
            
            // Тест ESP32
            if (SystemState.espIp && SystemState.espConnected) {
                try {
                    const img = new Image();
                    img.src = `http://${SystemState.espIp}/?t=${Date.now()}`;
                    
                    img.onload = () => {
                        addMessage('✓ ESP32: OK', 'system');
                    };
                    
                    img.onerror = () => {
                        addMessage('✗ ESP32: ОШИБКА', 'error');
                    };
                } catch (error) {
                    addMessage('✗ ESP32: ОШИБКА', 'error');
                }
            }
            
            addMessage('Тестирование завершено', 'system');
        }

        function resetSystem() {
            // Останавливаем все процессы
            if (SystemState.speechRecognition) {
                try {
                    SystemState.speechRecognition.stop();
                } catch (e) {}
            }
            
            if (SystemState.speechSynthesis) {
                window.speechSynthesis.cancel();
            }
            
            if (SystemState.visualizerInterval) {
                clearInterval(SystemState.visualizerInterval);
                SystemState.visualizerInterval = null;
            }
            
            if (SystemState.wakeLock) {
                SystemState.wakeLock.release();
                SystemState.wakeLock = null;
                document.getElementById('wakeLockIndicator').classList.remove('active');
            }
            
            // Останавливаем таймер
            if (SystemState.activationTimeout) {
                clearTimeout(SystemState.activationTimeout);
                SystemState.activationTimeout = null;
            }
            
            // Сбрасываем состояние
            SystemState.systemActive = false;
            SystemState.voiceEnabled = false;
            SystemState.listeningForActivation = false;
            SystemState.listeningForCommand = false;
            SystemState.isProcessing = false;
            SystemState.isSpeaking = false;
            SystemState.espConnected = false;
            SystemState.espTesting = false;
            
            // Сбрасываем UI
            updateInterfaceLanguage();
            updateStatusDisplay();
            
            const initBtn = document.getElementById('initBtn');
            if (initBtn) {
                initBtn.disabled = false;
                initBtn.innerHTML = '<i class="fas fa-rocket"></i><span id="initText">ИНИЦИАЛИЗИРОВАТЬ СИСТЕМУ</span>';
            }
            
            document.getElementById('espSection').style.display = 'none';
            document.getElementById('voiceControlSection').style.display = 'none';
            document.getElementById('quickActions').style.display = 'none';
            
            const voiceVisualizer = document.getElementById('voiceVisualizer');
            if (voiceVisualizer) voiceVisualizer.innerHTML = '';
            
            const t = SystemState.translations[SystemState.language];
            addMessage(t.systemReset, 'system');
        }

        function clearChat() {
            const messagesWrapper = document.getElementById('messagesWrapper');
            
            // Сохраняем первые три системных сообщения
            const systemMessages = Array.from(messagesWrapper.querySelectorAll('.message')).slice(0, 3);
            messagesWrapper.innerHTML = '';
            
            // Добавляем обратно системные сообщения
            systemMessages.forEach(msg => {
                messagesWrapper.appendChild(msg);
            });
            
            SystemState.logEntries = 3;
            updateMemoryStatus();
            
            addMessage('Чат очищен', 'system');
        }

        // ============================================
        // ИНИЦИАЛИЗАЦИЯ ПРИ ЗАГРУЗКЕ
        // ============================================
        document.addEventListener('DOMContentLoaded', () => {
            // Загружаем сохраненные настройки
            const savedApiKey = localStorage.getItem('pixel_api_key');
            const savedEspIp = localStorage.getItem('pixel_esp_ip');
            const savedLanguage = localStorage.getItem('pixel_language') || 'ru';
            
            if (savedApiKey) document.getElementById('apiKey').value = savedApiKey;
            if (savedEspIp) {
                document.getElementById('espIp').value = savedEspIp;
                SystemState.espIp = savedEspIp;
            }
            
            // Устанавливаем язык
            setLanguage(savedLanguage);
            
            // Автосохранение настроек
            document.getElementById('apiKey').addEventListener('input', (e) => {
                localStorage.setItem('pixel_api_key', e.target.value);
            });
            
            document.getElementById('espIp').addEventListener('input', (e) => {
                localStorage.setItem('pixel_esp_ip', e.target.value);
            });
            
            // Сохранение языка
            document.querySelectorAll('.lang-option').forEach(btn => {
                btn.addEventListener('click', function() {
                    const lang = this.textContent.trim() === 'РУССКИЙ' ? 'ru' : 'en';
                    localStorage.setItem('pixel_language', lang);
                });
            });
            
            // Быстрая отправка по Enter
            document.getElementById('apiKey').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') initializeSystem();
            });
            
            document.getElementById('espIp').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') connectToESP32();
            });
            
            // Обновление времени
            function updateTime() {
                const now = new Date();
                const timeElement = document.getElementById('currentTime');
                if (timeElement) {
                    timeElement.textContent = now.toLocaleTimeString('ru-RU', { 
                        hour: '2-digit', 
                        minute: '2-digit',
                        second: '2-digit'
                    });
                }
            }
            setInterval(updateTime, 1000);
            updateTime();
            
            // Восстановление при возврате на вкладку
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible' && SystemState.voiceEnabled) {
                    // Восстанавливаем Wake Lock
                    if ('wakeLock' in navigator && !SystemState.wakeLock) {
                        navigator.wakeLock.request('screen').then(wl => {
                            SystemState.wakeLock = wl;
                            document.getElementById('wakeLockIndicator').classList.add('active');
                        });
                    }
                    
                    // Восстанавливаем распознавание
                    if (SystemState.speechRecognition && !SystemState.isProcessing) {
                        setTimeout(() => {
                            if (SystemState.voiceEnabled) {
                                startRecognition();
                                addMessage('Распознавание восстановлено', 'system');
                            }
                        }, 500);
                    }
                }
            });
            
            // Предотвращаем закрытие страницы при активной системе
            window.addEventListener('beforeunload', (e) => {
                if (SystemState.voiceEnabled) {
                    e.preventDefault();
                    e.returnValue = SystemState.language === 'ru' 
                        ? 'Голосовое управление активно. Вы уверены, что хотите покинуть страницу?' 
                        : 'Voice control is active. Are you sure you want to leave the page?';
                    return e.returnValue;
                }
            });
        });
    </script>
</body>
</html>