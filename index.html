<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PIXEL AI: Trinity Edition</title>
    <style>
        :root { --neon: #ffaa00; --bg: #0a0a0a; }
        body { margin: 0; background: var(--bg); color: var(--neon); font-family: 'Courier New', monospace; height: 100vh; display: flex; flex-direction: column; }
        #terminal { flex: 1; padding: 20px; overflow-y: auto; font-size: 14px; line-height: 1.5; border-bottom: 1px solid #222; }
        .controls { padding: 20px; background: #111; display: flex; flex-direction: column; gap: 10px; }
        input { background: #000; border: 1px solid var(--neon); color: var(--neon); padding: 12px; border-radius: 5px; outline: none; }
        button { padding: 15px; background: var(--neon); border: none; font-weight: bold; border-radius: 5px; cursor: pointer; color: #000; }
        .sys { color: #00d2ff; }
        .ai { color: #fff; border-left: 2px solid var(--neon); padding-left: 10px; margin: 5px 0; }
        .user { color: #ff00e5; }
        .cmd { color: #00ff9d; font-weight: bold; }
        .blink { animation: blinker 1s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }
    </style>
</head>
<body>

<div style="padding: 10px; font-size: 12px; background: #111;">
    STATUS: <span id="st">READY</span> | CORE: TRINITY <span class="blink">_</span>
</div>

<div id="terminal"></div>

<div class="controls" id="setup">
    <input type="password" id="key" placeholder="OpenRouter API Key (sk-or-...)">
    <input type="text" id="ip" placeholder="IP Робота (ESP32)">
    <button onclick="boot()">ЗАПУСТИТЬ СИСТЕМУ</button>
</div>

<script>
    const term = document.getElementById('terminal');
    const st = document.getElementById('st');
    let config = { key: '', ip: '', active: false };
    
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = new SpeechRecognition();
    recognition.lang = 'ru-RU';
    recognition.continuous = false;

    function log(msg, cl = '') {
        const d = document.createElement('div');
        if(cl) d.className = cl;
        d.innerHTML = `> ${msg}`;
        term.appendChild(d);
        term.scrollTop = term.scrollHeight;
    }

    async function boot() {
        config.key = document.getElementById('key').value.trim();
        config.ip = document.getElementById('ip').value.trim();
        if(!config.key) return alert("Введите API ключ OpenRouter!");
        
        document.getElementById('setup').style.display = 'none';
        config.active = true;
        
        log("Инициализация Trinity через OpenRouter...", "sys");
        speak("Система активирована. Жду команды.", startWaitingForName);
    }

    // Этап 1: Ожидание активационного имени "Пиксель"
    function startWaitingForName() {
        if(!config.active) return;
        st.innerText = "LISTENING (NAME)";
        st.style.color = "#ffaa00";

        recognition.onresult = (event) => {
            const text = event.results[0][0].transcript.toLowerCase();
            log(`<span class="user">Слышу: "${text}"</span>`);
            
            if (text.includes("пиксель") || text.includes("pixel")) {
                handleTrigger();
            } else {
                safeRestart();
            }
        };

        recognition.onend = () => { if(st.innerText === "LISTENING (NAME)") safeRestart(); };
        try { recognition.start(); } catch(e) {}
    }

    // Этап 2: Реакция на имя и ожидание самой команды
    function handleTrigger() {
        st.innerText = "REPLYING";
        const reply = "Слушаю тебя!";
        log(`PIXEL: ${reply}`, "sys");
        
        speak(reply, () => {
            st.innerText = "LISTENING (CMD)";
            log("Говорите команду...", "sys");
            
            recognition.onresult = (event) => {
                const cmdText = event.results[0][0].transcript;
                log(`<span class="user">ЗАПРОС: ${cmdText}</span>`);
                askTrinity(cmdText);
            };
            
            recognition.onend = () => { if(st.innerText === "LISTENING (CMD)") safeRestart(); };
            try { recognition.start(); } catch(e) {}
        });
    }

    // Этап 3: Запрос к Trinity
    async function askTrinity(prompt) {
        st.innerText = "THINKING";
        log("Trinity анализирует...", "sys");

        try {
            const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                method: "POST",
                headers: {
                    "Authorization": `Bearer ${config.key}`,
                    "HTTP-Referer": window.location.href,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    "model": "arcee-ai/trinity-large-preview:free",
                    "messages": [
                        {
                            "role": "system",
                            "content": `Ты робот Пиксель. Отвечай кратко и по делу. Отвечай ТОЛЬКО на русском языке.

Доступные команды для управления роботом:
1. ДВИЖЕНИЕ:
   - MOVE_FORWARD|SPEED|TIME - вперед (скорость 0-100, время в мс)
   - MOVE_BACKWARD|SPEED|TIME - назад
   - ROTATE_LEFT|DEGREES|SPEED - поворот налево (градусы, скорость 0-100)
   - ROTATE_RIGHT|DEGREES|SPEED - поворот направо
   - STOP - полная остановка
   - TURN|DEGREES| - повернуться на градусы (использует гироскоп)

2. РЕЖИМЫ:
   - REMOTECONTROL_MODE - режим дистанционного управления
   - DANCE_1 - танец номер 1
   - DANCE_2 - танец номер 2
   - DANCE_3 - танец номер 3
   - DANCE_1,2,3 - несколько танцев сразу

3. УТИЛИТЫ:
   - LED_ON - включить светодиод на ESP32
   - LED_OFF - выключить светодиод
   - WAIT_5 - ждать 5 секунд (может быть любое число)

Формат ответа строго такой:
Text: [твой текстовый ответ на русском языке]
Commands: [команды через запятую или null]

Пример:
Пользователь: "Поезди вперед и поверни налево"
Ответ: 
Text: Еду вперед и поворачиваю налево.
Commands: MOVE_FORWARD|50|2000, ROTATE_LEFT|90|50

ВНИМАНИЕ:
1. Команды НЕ озвучиваются, только пишутся в терминал
2. Всегда отвечай на русском
3. Не используй смайлики в тексте
4. Если команда не нужна - пиши Commands: null
5. Для ожидания используй WAIT_<секунды>`
                        },
                        { "role": "user", "content": prompt }
                    ],
                    "temperature": 0.6
                })
            });

            const data = await response.json();
            
            if (data.error) throw new Error(data.error.message);

            const aiRaw = data.choices[0].message.content;
            
            // Извлекаем текстовый ответ и команды
            const txt = aiRaw.match(/Text:\s*(.*)/i)?.[1] || aiRaw;
            const cmdMatch = aiRaw.match(/Commands:\s*(.*)/i);
            let cmds = cmdMatch ? cmdMatch[1] : "null";
            
            // Очищаем команды от лишних пробелов
            cmds = cmds.replace(/\s+/g, '').toUpperCase();
            
            // Выводим ответ ИИ
            log(`PIXEL: ${txt}`, "ai");
            
            // Выводим команды отдельно (не озвучиваем!)
            if (cmds !== "NULL" && cmds !== "") {
                const commands = cmds.split(',').filter(cmd => cmd.trim() !== '');
                commands.forEach(cmd => {
                    log(`<span class="cmd">>>> КОМАНДА: ${cmd}</span>`, "sys");
                    if(config.ip) {
                        // Отправляем команду на ESP32
                        sendToESP32(cmd.trim());
                    }
                });
            }

            // Озвучиваем только текстовый ответ (без команд)
            speak(txt, startWaitingForName);

        } catch (e) {
            log("ОШИБКА: " + e.message, "sys");
            speak("Произошла ошибка при обработке запроса", startWaitingForName);
        }
    }

    function sendToESP32(command) {
        if(!config.ip) {
            log("IP ESP32 не указан", "sys");
            return;
        }
        
        // Отправляем команду на ESP32
        fetch(`http://${config.ip}/command`, { 
            method: "POST", 
            mode: "no-cors", 
            body: command 
        }).catch(err => {
            log(`Ошибка отправки команды: ${err.message}`, "sys");
        });
        
        log(`Команда [${command}] отправлена на ESP32`, "sys");
    }

    function speak(text, callback) {
        window.speechSynthesis.cancel();
        const msg = new SpeechSynthesisUtterance(text);
        msg.lang = 'ru-RU';
        msg.rate = 0.9; // Немного медленнее для лучшего понимания
        msg.onend = callback;
        window.speechSynthesis.speak(msg);
    }

    function safeRestart() {
        if(config.active) setTimeout(() => { 
            try { 
                recognition.start(); 
            } catch(e) {} 
        }, 100);
    }
</script>
</body>
</html>